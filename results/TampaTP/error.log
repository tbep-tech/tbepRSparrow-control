RSPARROW SYSTEM ERROR OCCURRED
To reset user options in R use options(backupOptions)
 
Error: Tibble columns must have compatible sizes.
* Size 2: Column `name`.
* Size 10597: Columns `x`, `y`, `text`, and `.plotlyGroupIndex`.
i Only values of size one are recycled.
Backtrace:
     x
  1. \-global::predictMaps(...)
  2.   \-rmarkdown::render(...)
  3.     \-knitr::knit(knit_input, knit_output, envir = envir, quiet = quiet)
  4.       \-knitr:::process_file(text, output)
  5.         +-base::withCallingHandlers(...)
  6.         +-knitr:::process_group(group)
  7.         \-knitr:::process_group.block(group)
  8.           \-knitr:::call_block(x)
  9.             \-knitr:::block_exec(params)
 10.               +-knitr:::in_dir(...)
 11.               \-knitr:::evaluate(...)
 12.                 \-evaluate::evaluate(...)
 13.                   \-evaluate:::evaluate_call(...)
 14.                     +-base:::handle(...)
 15.                     +-base::withCallingHandlers(...)
 16.                     +-base::withVisible(value_fun(ev$value, ev$visible))
 17.              

Traceback:
41: stop(fallback)
40: signal_abort(cnd)
39: cnd_signal(error_incompatible_size(.rows, names(x), lengths, 
        "Requested with `.rows` argument"))
38: recycle_columns(x, .rows, lengths)
37: lst_to_tibble(x, .rows, .name_repair, col_lengths(x))
36: as_tibble.list(tr)
35: tibble::as_tibble(tr)
34: (function (x, y) 
    {
        dat <- plotly_data(p, y)
        trace <- structure(rapply(x, eval_attr, data = dat, how = "list"), 
            class = oldClass(x))
        trace <- verify_type(trace)
        trace <- verify_orientation(trace)
        trace <- coerce_attr_defaults(trace, p$x$layout)
        if (crosstalk_key() %in% names(dat) && isTRUE(trace[["inherit"]] %||% 
            TRUE)) {
            trace[["key"]] <- trace[["key"]] %||% dat[[crosstalk_key()]]
            trace[["set"]] <- trace[["set"]] %||% attr(dat, "set")
        }
        grps <- if (has_group(trace)) 
            tryNULL(dplyr::group_vars(dat))
        if (length(grps) && any(lengths(trace) == NROW(dat))) {
            trace[[".plotlyGroupIndex"]] <- interaction(dat[, grps, 
                drop = F])
        }
        for (i in c("x", "y", "z")) {
            nm <- paste0(i, "axis")
            idx <- which(names(trace) %in% i)
            if (length(idx) == 1) {
                title <- default(deparse2(x[[idx]]))
                if (is3d(trace$type) || i == "z") {
                    p$x$layout$scene[[nm]]$title <<- p$x$layout$scene[[nm]]$title %||% 
                      title
                }
                else {
                    p$x$layout[[nm]]$title <<- p$x$layout[[nm]]$title %||% 
                      title
                }
            }
        }
        if (inherits(trace, c("plotly_surface", "plotly_contour"))) {
            if (!is.matrix(trace[["z"]]) || !is.numeric(trace[["z"]])) {
                stop("`z` must be a numeric matrix", call. = FALSE)
            }
        }
        Attrs <- Schema$traces[[trace[["type"]]]]$attributes
        isArray <- vapply(Attrs, function(x) {
            tryFALSE(identical(x[["valType"]], "data_array"))
        }, logical(1))
        arrayOk <- vapply(Attrs, function(x) tryNULL(x[["arrayOk"]]) %||% 
            FALSE, logical(1))
        dataArrayAttrs <- if (is_tidy(trace)) 
            names(Attrs)[isArray | arrayOk]
        allAttrs <- c(dataArrayAttrs, special_attrs(trace), npscales(), 
            "frame", ".plotlyGroupIndex", "text", "key", "fillcolor", 
            "name", "legendgroup")
        tr <- trace[names(trace) %in% allAttrs]
        tr <- tr[vapply(tr, function(x) is.null(dim(x)) && is.atomic(x), 
            logical(1))]
        tr$customdata <- trace$customdata
        builtData <- tibble::as_tibble(tr)
        for (i in seq_along(tr)) {
            if (inherits(tr[[i]], "AsIs")) 
                builtData[[i]] <- I(builtData[[i]])
        }
        if (NROW(builtData) > 0) {
            isAsIs <- vapply(builtData, function(x) inherits(x, "AsIs"), 
                logical(1))
            isDiscrete <- vapply(builtData, is.discrete, logical(1))
            isSplit <- names(builtData) %in% c("split", "linetype", 
                "frame", "fillcolor", "name") | !isAsIs & isDiscrete & 
                names(builtData) %in% c("symbol", "color")
            if (any(isSplit)) {
                paste2 <- function(x, y) if (identical(x, y)) 
                    x
                else paste(x, y, sep = br())
                splitVars <- builtData[isSplit]
                builtData[[".plotlyTraceIndex"]] <- Reduce(paste2, 
                    splitVars)
                trace$frameOrder <- which(names(splitVars) %in% "frame")
            }
            builtData <- arrange_safe(builtData, ".plotlyTraceIndex")
            isComplete <- complete.cases(builtData[names(builtData) %in% 
                c("x", "y", "z")])
            if (any(!isComplete) && !has_group(trace)) {
                warning("Ignoring ", sum(!isComplete), " observations", 
                    call. = FALSE)
            }
            builtData[[".plotlyMissingIndex"]] <- cumsum(!isComplete)
            builtData <- builtData[isComplete, ]
            if (length(grps) && has_group(trace) && isTRUE(trace[["connectgaps"]])) {
                stop("Can't use connectgaps=TRUE when data has group(s).", 
                    call. = FALSE)
            }
            builtData[[".plotlyGroupIndex"]] <- interaction(builtData[[".plotlyGroupIndex"]] %||% 
                "", builtData[[".plotlyMissingIndex"]])
            builtData <- arrange_safe(builtData, c(".plotlyTraceIndex", 
                ".plotlyGroupIndex", if (inherits(trace, "plotly_line")) "x"))
            builtData <- train_data(builtData, trace)
            trace[[".plotlyVariableMapping"]] <- names(builtData)
            for (i in names(builtData)) {
                trace[[i]] <- builtData[[i]]
            }
        }
        trace[c("ymin", "ymax", "yend", "xend")] <- NULL
        trace[lengths(trace) > 0]
    })(dots[[1L]][[2L]], dots[[2L]][[2L]])
33: mapply(FUN = f, ..., SIMPLIFY = FALSE)
32: Map(function(x, y) {
        dat <- plotly_data(p, y)
        trace <- structure(rapply(x, eval_attr, data = dat, how = "list"), 
            class = oldClass(x))
        trace <- verify_type(trace)
        trace <- verify_orientation(trace)
        trace <- coerce_attr_defaults(trace, p$x$layout)
        if (crosstalk_key() %in% names(dat) && isTRUE(trace[["inherit"]] %||% 
            TRUE)) {
            trace[["key"]] <- trace[["key"]] %||% dat[[crosstalk_key()]]
            trace[["set"]] <- trace[["set"]] %||% attr(dat, "set")
        }
        grps <- if (has_group(trace)) 
            tryNULL(dplyr::group_vars(dat))
        if (length(grps) && any(lengths(trace) == NROW(dat))) {
            trace[[".plotlyGroupIndex"]] <- interaction(dat[, grps, 
                drop = F])
        }
        for (i in c("x", "y", "z")) {
            nm <- paste0(i, "axis")
            idx <- which(names(trace) %in% i)
            if (length(idx) == 1) {
                title <- default(deparse2(x[[idx]]))
                if (is3d(trace$type) || i == "z") {
                    p$x$layout$scene[[nm]]$title <<- p$x$layout$scene[[nm]]$title %||% 
                      title
                }
                else {
                    p$x$layout[[nm]]$title <<- p$x$layout[[nm]]$title %||% 
                      title
                }
            }
        }
        if (inherits(trace, c("plotly_surface", "plotly_contour"))) {
            if (!is.matrix(trace[["z"]]) || !is.numeric(trace[["z"]])) {
                stop("`z` must be a numeric matrix", call. = FALSE)
            }
        }
        Attrs <- Schema$traces[[trace[["type"]]]]$attributes
        isArray <- vapply(Attrs, function(x) {
            tryFALSE(identical(x[["valType"]], "data_array"))
        }, logical(1))
        arrayOk <- vapply(Attrs, function(x) tryNULL(x[["arrayOk"]]) %||% 
            FALSE, logical(1))
        dataArrayAttrs <- if (is_tidy(trace)) 
            names(Attrs)[isArray | arrayOk]
        allAttrs <- c(dataArrayAttrs, special_attrs(trace), npscales(), 
            "frame", ".plotlyGroupIndex", "text", "key", "fillcolor", 
            "name", "legendgroup")
        tr <- trace[names(trace) %in% allAttrs]
        tr <- tr[vapply(tr, function(x) is.null(dim(x)) && is.atomic(x), 
            logical(1))]
        tr$customdata <- trace$customdata
        builtData <- tibble::as_tibble(tr)
        for (i in seq_along(tr)) {
            if (inherits(tr[[i]], "AsIs")) 
                builtData[[i]] <- I(builtData[[i]])
        }
        if (NROW(builtData) > 0) {
            isAsIs <- vapply(builtData, function(x) inherits(x, "AsIs"), 
                logical(1))
            isDiscrete <- vapply(builtData, is.discrete, logical(1))
            isSplit <- names(builtData) %in% c("split", "linetype", 
                "frame", "fillcolor", "name") | !isAsIs & isDiscrete & 
                names(builtData) %in% c("symbol", "color")
            if (any(isSplit)) {
                paste2 <- function(x, y) if (identical(x, y)) 
                    x
                else paste(x, y, sep = br())
                splitVars <- builtData[isSplit]
                builtData[[".plotlyTraceIndex"]] <- Reduce(paste2, 
                    splitVars)
                trace$frameOrder <- which(names(splitVars) %in% "frame")
            }
            builtData <- arrange_safe(builtData, ".plotlyTraceIndex")
            isComplete <- complete.cases(builtData[names(builtData) %in% 
                c("x", "y", "z")])
            if (any(!isComplete) && !has_group(trace)) {
                warning("Ignoring ", sum(!isComplete), " observations", 
                    call. = FALSE)
            }
            builtData[[".plotlyMissingIndex"]] <- cumsum(!isComplete)
            builtData <- builtData[isComplete, ]
            if (length(grps) && has_group(trace) && isTRUE(trace[["connectgaps"]])) {
                stop("Can't use connectgaps=TRUE when data has group(s).", 
                    call. = FALSE)
            }
            builtData[[".plotlyGroupIndex"]] <- interaction(builtData[[".plotlyGroupIndex"]] %||% 
                "", builtData[[".plotlyMissingIndex"]])
            builtData <- arrange_safe(builtData, c(".plotlyTraceIndex", 
                ".plotlyGroupIndex", if (inherits(trace, "plotly_line")) "x"))
            builtData <- train_data(builtData, trace)
            trace[[".plotlyVariableMapping"]] <- names(builtData)
            for (i in names(builtData)) {
                trace[[i]] <- builtData[[i]]
            }
        }
        trace[c("ymin", "ymax", "yend", "xend")] <- NULL
        trace[lengths(trace) > 0]
    }, attrsToEval, names2(attrsToEval))
31: plotly_build.plotly(instance)
30: instance$preRenderHook(instance)
29: createPayload(x)
28: toJSON(createPayload(x))
27: widget_data(x, id)
26: dots_list(...)
25: htmltools::tagList(container(htmltools::tagList(x$prepend, widget_html(name = class(x)[1], 
        package = attr(x, "package"), id = id, style = style, class = paste(class(x)[1], 
            "html-widget"), width = sizeInfo$width, height = sizeInfo$height), 
        x$append)), widget_data(x, id), if (!is.null(sizeInfo$runtime)) {
        tags$script(type = "application/htmlwidget-sizing", `data-for` = id, 
            toJSON(sizeInfo$runtime))
    })
24: toHTML(x, standalone = FALSE, knitrOptions = options)
23: need_screenshot(x, ...)
22: knitr::knit_print(toHTML(x, standalone = FALSE, knitrOptions = options), 
        options = options, ...)
21: knit_print.htmlwidget(x, ...)
20: knit_print(x, ...)
19: withVisible(knit_print(x, ...))
18: fun(x, options = options)
17: value_fun(ev$value, ev$visible)
16: withVisible(value_fun(ev$value, ev$visible))
15: withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), 
        warning = wHandler, error = eHandler, message = mHandler)
14: handle(pv <- withCallingHandlers(withVisible(value_fun(ev$value, 
        ev$visible)), warning = wHandler, error = eHandler, message = mHandler))
13: evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, 
        debug = debug, last = i == length(out), use_try = stop_on_error != 
            2L, keep_warning = keep_warning, keep_message = keep_message, 
        output_handler = output_handler, include_timing = include_timing)
12: evaluate::evaluate(...)
11: evaluate(code, envir = env, new_device = FALSE, keep_warning = !isFALSE(options$warning), 
        keep_message = !isFALSE(options$message), stop_on_error = if (options$error && 
            options$include) 0L else 2L, output_handler = knit_handlers(options$render, 
            options))
10: in_dir(input_dir(), evaluate(code, envir = env, new_device = FALSE, 
        keep_warning = !isFALSE(options$warning), keep_message = !isFALSE(options$message), 
        stop_on_error = if (options$error && options$include) 0L else 2L, 
        output_handler = knit_handlers(options$render, options)))
9: block_exec(params)
8: call_block(x)
7: process_group.block(group)
6: process_group(group)
5: withCallingHandlers(if (tangle) process_tangle(group) else process_group(group), 
       error = function(e) {
           setwd(wd)
           cat(res, sep = "\n", file = output %n% "")
           message("Quitting from lines ", paste(current_lines(i), 
               collapse = "-"), " (", knit_concord$get("infile"), 
               ") ")
       })
4: process_file(text, output)
3: knitr::knit(knit_input, knit_output, envir = envir, quiet = quiet)
2: rmarkdown::render(paste0(path_master, "predictMaps.Rmd"), params = list(predictMapType = "stream", 
       GeoLines = GeoLines, plotShape = lineShape, k = k, existGeoLines = existGeoLines, 
       Rshiny = Rshiny, input = input, predictionTitleSize = predictionTitleSize, 
       scenario_name = scenario_name, scenario_map_list = scenario_map_list, 
       master_map_list = master_map_list, predictionLegendSize = predictionLegendSize, 
       mapunits.list = mapunits.list, predictionLegendBackground = predictionLegendBackground, 
       break1 = break1, Mcolors = Mcolors, enable_plotlyMaps = enable_plotlyMaps, 
       output_map_type = output_map_type, lineWidth = lineWidth, 
       lon_limit = lon_limit, lat_limit = lat_limit, nlty = nlty, 
       nlwd = nlwd, mapdataname = mapdataname, predictionMapColors = predictionMapColors, 
       add_plotlyVars = add_plotlyVars, mapScenarios = mapScenarios, 
       predictionMapBackground = predictionMapBackground, LineShapeGeo = LineShapeGeo, 
       mapvarname = mapvarname, predictionClassRounding = predictionClassRounding, 
       commonvar = commonvar), output_file = htmlFile, quiet = TRUE)
1: predictMaps(input, allMetrics, output_map_type, Rshiny, file.output.list, 
       data_names, mapping.input.list, subdata, mapScenarios, scenario_map_list, 
       predictScenarios.list, scenarioFlag, batch_mode)
